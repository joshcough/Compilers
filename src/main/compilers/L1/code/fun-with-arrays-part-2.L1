((
  (eax <- (allocate 101 3)) ; size 50 array of 1's.
  (edi <- eax) ; save the array pointer in edi
  (ebx <- 50) ; the array index
  (edx <- 1) ; what to put in the array

  ; fill the array backwards so it contains 50 -> 1
  :filler

  (ecx <- ebx) ; save the current index in ecx
  (ecx *= 4) ; times by 4 for the real array position
  (ecx += edi) ; add in the base pointer 
  (esi <- edx) ; encode edx in esi
  (esi *= 2)
  (esi += 1)
  ((mem ecx 0) <- esi)

  (ebx -= 1)
  (edx += 1)
  (cjump ebx < 1 :printer :filler)

  :printer
  (ebx <- 1)

  :printer2
  ; print the elements in the array from start to finish
  (esi <- ebx) ; ebx is still the array index
  (esi *= 4) ; get the real array index
  (esi += edi) ; add in the base pointer
  (esi <- (mem esi 0)) ; put the 1st element into esi
  (eax <- (print esi)) ; print it
  (edx <- 51)
  (ebx += 1)
  (cjump ebx < edx :printer2 :ender)

  :ender
  (eax <- (print edi)) 
))
