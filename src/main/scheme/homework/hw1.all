//////////////////////////
/////// SCALA ////////////
//////////////////////////

// FILE: homework/HW1.scala

package homework

object HW1 {

  trait Exp
  case class StringLit(s:String) extends Exp
  case class Concat(left: Exp, right: Exp) extends Exp
  case class RestAfter(left: Exp, right: Exp) extends Exp

  object HW1Interpreter extends Interpreter[Exp, String] with Parser[Exp] {
    def eval(exp: Exp): String = {
      exp match {
        case StringLit(s) => s.drop(1).dropRight(1)
        case Concat(l, r) => eval(l) + eval(r)
        case RestAfter(l, r) => {
          val ls = eval(l)
          val rs = eval(r)
          val i = ls indexOf rs
          if (i == -1) error(rs + " not in " + ls) else ls.substring(i+1)
        }
      }
    }

    def parse(expr: Any): Exp = {
      expr match {
        case s: String => StringLit(s)
        case List(xs, "&", ys) => Concat(parse(xs), parse(ys))
        case List(xs, "@", ys) => RestAfter(parse(xs), parse(ys))
        case _ => error("unexpected token: " + expr)
      }
    }
  }
}

trait Interpreter[E,V] {
  def eval(exp: E): V
}

trait Parser[E] {
  def parse(exp: Any): E
}

class Reader {

  def read(s:String): Any = read(s.toStream)

  def read(stream:Stream[Char]): Any = readWithRest(stream)._1

  def readWithRest(stream:Stream[Char]): (Any, Stream[Char]) = {

    def readList(stream: Stream[Char], acc: List[Any]): (List[Any], Stream[Char]) = {
      stream match {
        case ')' #:: tail => (acc, tail)
        case x   #:: tail =>
          val (next, rest) = readWithRest(stream)
          readList(rest, acc ::: List(next))
	case Stream()     => error("unterminated list")
      }
    }

    def readChars(stream:Stream[Char]): (String, Stream[Char]) = {
      val (chars, rest) = stream.span( ! List('(', ')', ' ').contains(_) )
      (chars.mkString, rest)
    }

    def readStringLit(stream: Stream[Char], acc: String): (String, Stream[Char]) = {
      stream match {
        case '"' #:: tail => (acc + '"', tail)
        case c   #:: tail => readStringLit(tail, acc + c)
	case Stream()     => error("unterminated string literal")
      }
    }

    stream match {
      case '(' #:: tail => readList(tail, Nil)
      case ' ' #:: tail => readWithRest(tail)
      case '"' #:: tail => readStringLit(tail, "\"")
      case ')' #:: _    => error("unexpected token )")
      case _ => readChars(stream)
    }
  }
}

// FILE: homework/HW1Test.scala

package homework

import HW1._

class HW1Test extends HWBaseTest[Exp, String](HW1Interpreter){

  testCode(""" "hello" """ -> "hello")
  testCode(""" (("hello" & " ") & "world") """ -> "hello world")
  testCode(""" (("hello" @ "l") & ("a world" @ "a")) """ -> "lo world")
  testCode(""" ("filename.scm" @ ".") """ -> "scm")
}

// FILE: homework/HWBaseTest.scala

abstract class HWBaseTest[E,V](val interpreter:Interpreter[E,V] with Parser[E]) extends org.scalatest.FunSuite {

  def testCode(t: (String, V)): Unit = {
    test(t._1 + " mustBe " + t._2){
      assert(interpreter.eval(interpreter.parse(new Reader().read(t._1))) === t._2)
    }
  }

  def testExp(t: (E, V)): Unit = {
    println("calling test with: " + t)
    test(t._1 + " mustBe " + t._2){ assert(interpreter.eval(t._1) === t._2) }
  }
}

// FILE: homework/ReaderTest.scala

package homework

import org.scalatest.FunSuite
import org.scalatest.matchers.MustMatchers

class ReaderTest extends FunSuite with MustMatchers {

  testRead("hello" -> "hello")
  testRead("\"hello\"" -> "\"hello\"")
  testRead("\"hello world\"" -> "\"hello world\"")

  testRead("(hey world)" -> List("hey", "world"))
  testRead("(\"hey\" world)" -> List("\"hey\"", "world"))

  def testRead(t: (String,Any)){
    test(t._1 + " must be " + t._2 ){
      new Reader().read(t._1.toStream) must be(t._2)
    }
  }
}

;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;; SCHEME ;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

;; FILE homework/hw1.ss

;; The first three lines of this file were inserted by DrScheme. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(planet plai/plai:1:6/lang/reader)

(define-type EXP
  [string-lit (n string?)]
  [concat (left EXP?) (right EXP?)]
  [rest-after (left EXP?) (right EXP?)]
)

(define (parse sexp)
  (cond
    [(string? sexp) (string-lit sexp)]
    [(list? sexp)
     (case (second sexp)
       [(&) (concat (parse (first sexp)) (parse (third sexp)))]
       [(@) (rest-after (parse (first sexp)) (parse (third sexp)))]
       )]
    [else (error "unexpected token")]
    ))

(define (crazy-string-find-thing findme instring)
  (cond
    [(> (string-length findme) (string-length instring)) (error (string-append findme " not found in " instring))]
    [(string=? findme (substring instring 0 (string-length findme))) (substring instring (string-length findme))]
    [else (crazy-string-find-thing findme (substring instring 1))]))

(define (interpret exp)
  (type-case EXP exp
             [string-lit (s) s]
             [concat (l r) (string-append (interpret l) (interpret r))]
             [rest-after (l r) (crazy-string-find-thing (interpret r) (interpret l))]))

(define (testcode l r)(test (interpret(parse l)) r))
(define (testcode/exn l r)(test/exn (interpret(parse l)) r))

(testcode "" "")
(testcode "hello" "hello")
(testcode '(("hello" & " ") & "world") "hello world")
(testcode '(("hello" @ "l") & ("a world" @ "a")) "lo world")
(testcode '((("a" & "b") & ("a" & "b")) & (("a" & "b") & ("a" & "b"))) "abababab")
(testcode '(((((("abababab" @ "a") @ "b") @ "a") @ "b") @ "a") @ "b") "ab")
(testcode '((((((("a" & "b") & ("a" & "b")) & (("a" & "b") & ("a" & "b"))) @ "ab") @ "ab") @ "ab") @ "ab") "")
(testcode '("filename.scm" @ ".") "scm")
(testcode/exn 6 "unexpected token")
(testcode/exn '("x" @ "hello") "hello not found in x")
(testcode/exn '("" @ "x") "x not found in ")
(testcode/exn '(("" & "") @ "x") "x not found in ")
(testcode/exn '(((((((("a" & "b") & ("a" & "b")) & (("a" & "b") & ("a" & "b"))) @ "ab") @ "ab") @ "ab") @ "ab") @ "x") "x not found in ")